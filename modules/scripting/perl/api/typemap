TYPEMAP
Atheme_Sourceinfo		T_PTROBJ_SPECIAL
Atheme_Command			T_PTROBJ_SPECIAL
Atheme_Service			T_PTROBJ_SPECIAL
Atheme_User			T_PTROBJ_SPECIAL
Atheme_Entity			T_PTROBJ_SPECIAL
Atheme_Account			T_PTROBJ_SPECIAL
Atheme_Channel			T_PTROBJ_SPECIAL
Atheme_ChanUser			T_PTROBJ_SPECIAL
Atheme_ChannelRegistration	T_PTROBJ_SPECIAL

Atheme_Internal_List		T_PTROBJ_TIEDARRAY

INPUT
T_PTROBJ_SPECIAL
	do
	{
		SV *arg = $arg;
		SV *ref = SvRV(arg);
		const char * type = \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\";
		if ( sv_isobject(arg) && (SvTYPE(SvRV(arg)) == SVt_PVMG) &&
		    sv_derived_from(arg, type)) {
			IV tmp = SvIV(ref);
			$var = INT2PTR($type, tmp);
		}
		else
			croak(\"$var is not of type ${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\");
	} while(0)

T_PTROBJ_TIEDARRAY
	do
	{
		SV *arg = $arg;
		SV *ref = SvRV(arg);
		const char * type = \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\";
		if ( sv_isobject(arg) && (SvTYPE(SvRV(arg)) == SVt_PVMG) &&
		    sv_derived_from(arg, type)) {
			IV tmp = SvIV(ref);
			$var = INT2PTR($type, tmp);
		}
		else
			croak(\"$var is not of type ${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\");
	} while(0)

OUTPUT
T_PTROBJ_SPECIAL
	sv_setref_pv($arg, \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\", (void*)$var);

T_PTROBJ_TIEDARRAY
	do {
		AV *array = newAV();
		SV *tie = newSV(0);
		sv_setref_pv(tie, \"${(my $ntt=$ntype)=~s/_/::/g;\$ntt}\", (void*)$var);
		hv_magic(array, tie, PERL_MAGIC_tied);
		$arg = newRV_noinc((SV*)array);
	} while(0);
